/*
 Navicat Premium Data Transfer

 Source Server         : admin
 Source Server Type    : MySQL
 Source Server Version : 50726
 Source Host           : localhost:3306
 Source Schema         : boke

 Target Server Type    : MySQL
 Target Server Version : 50726
 File Encoding         : 65001

 Date: 05/09/2021 21:14:43
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for ms_admin
-- ----------------------------
DROP TABLE IF EXISTS `ms_admin`;
CREATE TABLE `ms_admin`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_admin
-- ----------------------------
INSERT INTO `ms_admin` VALUES (1, 'piaopiao', '$2a$10$RZECQ90DjOT/t1mhnXsl5.XSuZWc0Sa1XduPxj2rb4yaSYcje3nWW');
INSERT INTO `ms_admin` VALUES (2, 'boke', '$2a$10$RZECQ90DjOT/t1mhnXsl5.XSuZWc0Sa1XduPxj2rb4yaSYcje3nWW');

-- ----------------------------
-- Table structure for ms_admin_permission
-- ----------------------------
DROP TABLE IF EXISTS `ms_admin_permission`;
CREATE TABLE `ms_admin_permission`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `admin_id` bigint(20) NOT NULL,
  `permission_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_admin_permission
-- ----------------------------
INSERT INTO `ms_admin_permission` VALUES (1, 1, 1);
INSERT INTO `ms_admin_permission` VALUES (2, 2, 1);

-- ----------------------------
-- Table structure for ms_article
-- ----------------------------
DROP TABLE IF EXISTS `ms_article`;
CREATE TABLE `ms_article`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `comment_counts` int(11) NULL DEFAULT NULL COMMENT '评论数量',
  `create_date` bigint(20) NULL DEFAULT NULL COMMENT '创建时间',
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '简介',
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `view_counts` int(11) NULL DEFAULT NULL COMMENT '浏览数量',
  `weight` int(11) NOT NULL COMMENT '是否置顶',
  `author_id` bigint(20) NULL DEFAULT NULL COMMENT '作者id',
  `body_id` bigint(20) NULL DEFAULT NULL COMMENT '内容id',
  `category_id` int(11) NULL DEFAULT NULL COMMENT '类别id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1434503969752772611 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_article
-- ----------------------------
INSERT INTO `ms_article` VALUES (1, 4, 1621947720727, '通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。', 'springboot介绍以及入门案例', 146, 0, 1, 1, 2);
INSERT INTO `ms_article` VALUES (9, 1, 1613947720727, 'Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。', 'Vue.js 到底是什么', 3, 0, 1, 20, 1);
INSERT INTO `ms_article` VALUES (10, 1, 1523947720727, '本节将介绍如何在项目中使用 Element。', 'Element相关', 15, 0, 1, 21, 1);
INSERT INTO `ms_article` VALUES (1405916999732707300, 0, 1624031708047, 'springboot入门案例', 'SpringBoot入门案例', 18, 0, 1, 1405916999854342146, 2);
INSERT INTO `ms_article` VALUES (1427273234172092417, 1, 1629123431135, 'RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。', 'RPC（远程过程调用）', 9, 0, 1427264611798757377, 1427273234843181058, 2);
INSERT INTO `ms_article` VALUES (1427276445754884097, 2, 1629124196836, 'Apache Dubbo是一款高性能的Java RPC框架。', 'Apache Dubbo入门', 16, 0, 1, 1427276446841208833, 2);
INSERT INTO `ms_article` VALUES (1427278899737296897, 1, 1629124781928, 'Docker镜像是由文件系统叠加而成（是一种文件的存储形式）。', 'Docker常用命令大全', 12, 1, 1, 1427278901641510913, 5);
INSERT INTO `ms_article` VALUES (1427491228018044929, 0, 1629175404919, 'FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制', 'FastDFS介绍', 3, 0, 1, 1427491230954057729, 2);
INSERT INTO `ms_article` VALUES (1427510750640893954, 0, 1629180059491, 'Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。', 'Lua脚本(了解)', 1, 0, 1, 1427510754017308673, 1);
INSERT INTO `ms_article` VALUES (1427644735320879106, 0, 1629212003912, 'Sentinel（哨兵）可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能，', 'Redis哨兵模式', 4, 0, 1, 1427644736361066497, 2);
INSERT INTO `ms_article` VALUES (1427646422928453634, 0, 1629212406272, '这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。', 'Redis缓存击穿、缓存雪崩', 4, 0, 1, 1427646424123830273, 4);
INSERT INTO `ms_article` VALUES (1434503969752772610, 0, 1630847372838, 'SSM个人博客项目开源', 'Gitee开源博客项目', 1, 0, 1427297981920456706, 1434503971032035329, 3);

-- ----------------------------
-- Table structure for ms_article_body
-- ----------------------------
DROP TABLE IF EXISTS `ms_article_body`;
CREATE TABLE `ms_article_body`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `article_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1434503971032035330 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_article_body
-- ----------------------------
INSERT INTO `ms_article_body` VALUES (1, '# 1. Spring Boot介绍\r\n\r\n## 1.1 简介\r\n\r\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\r\n\r\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\r\n\r\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\r\n\r\nSpring Boot让我们的Spring应用变的更轻量化。\r\n\r\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\r\n\r\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\r\n\r\n**总结一下Spring Boot的主要优点：**\r\n\r\n1. 为所有Spring开发者更快的入门\r\n2. 开箱即用，提供各种默认配置来简化项目配置\r\n3. 内嵌式容器简化Web项目\r\n4. 没有冗余代码生成和XML配置的要求\r\n5. 统一的依赖管理\r\n6. 自动装配，更易使用，更易扩展\r\n\r\n## 1.2 使用版本说明\r\n\r\nSpringboot版本：使用最新的2.5.0版本\r\n\r\n教程参考了官方文档进行制作，权威。\r\n\r\n其他依赖版本：\r\n\r\n	1. Maven  需求：3.5+\r\n\r\n   	2. JDK 需求  8+\r\n   	3. Spring Framework 5.3.7以上版本\r\n   	4. Tomcat 9.0\r\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\r\n\r\n# 2. 快速入门\r\n\r\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\r\n\r\n教程使用的Idea版本：2019.3\r\n\r\n## 2.1 创建基础项目\r\n\r\n**第一步：** 创建maven项目\r\n\r\npom.xml :\r\n\r\n~~~xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.xiaopizhu</groupId>\r\n    <artifactId>helloSpringBoot</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.5.0</version>\r\n    </parent>\r\n</project>\r\n~~~\r\n\r\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\r\n\r\n此时的工程结构为：\r\n\r\n![image-20210523173241557](img/image-20210523173241557.png)\r\n\r\n**第二步：** 添加web依赖\r\n\r\n~~~xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-web</artifactId>\r\n    </dependency>\r\n</dependencies>\r\n~~~\r\n\r\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\r\n\r\n**第三步：** 编写启动类\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class HelloApp {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(HelloApp.class,args);\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\r\n\r\n**第四步：** 运行启动类的main方法\r\n\r\n![image-20210523173712142](img/image-20210523173712142.png)\r\n\r\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\r\n\r\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\r\n\r\n~~~properties\r\nserver.port=8082\r\n~~~\r\n\r\n**第六步：** 重新运行\r\n\r\n![image-20210523174011613](img/image-20210523174011613.png)\r\n\r\n此时的项目结构为：\r\n\r\n![image-20210523174032053](img/image-20210523174032053.png)\r\n\r\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\r\n\r\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\r\n\r\n**src/test/java:**  测试代码\r\n\r\n## 2.2 编写一个Http接口\r\n\r\n**第一步：**创建`HelloController`类，内容如下：\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\n@RequestMapping(\"hello\")\r\npublic class HelloController {\r\n\r\n    @GetMapping(\"boot\")\r\n    public String hello(){\r\n        return \"hello spring boot\";\r\n    }\r\n\r\n}\r\n\r\n~~~\r\n\r\n**注意包名，必须在启动类所在的包名下。**\r\n\r\n**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.3 编写单元测试用例\r\n\r\n**第一步：**添加spring boot测试依赖\r\n\r\n~~~xml\r\n		<dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n~~~\r\n\r\n**第二步：**在src/test 下，编写测试用例\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.junit.jupiter.api.BeforeAll;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.test.web.servlet.MockMvc;\r\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\r\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\r\n\r\nimport static org.hamcrest.Matchers.equalTo;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\r\n\r\n@SpringBootTest\r\npublic class TestHelloController {\r\n\r\n    private MockMvc mockMvc;\r\n\r\n    @BeforeEach\r\n    public void beforeEach(){\r\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\r\n    }\r\n    @Test\r\n    public void testHello() throws Exception {\r\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\r\n                .accept(MediaType.APPLICATION_JSON))\r\n                .andExpect(status().isOk())\r\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\r\n\r\n## 2.4 打包为jar运行\r\n\r\n**第一步：**添加打包(maven构建springboot)插件\r\n\r\n~~~xml\r\n  <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n~~~\r\n\r\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\r\n\r\n![image-20210523181737720](img/image-20210523181737720.png)\r\n\r\n**第二步：**打开cmd：找到jar对应的目录\r\n\r\n输入命令\r\n\r\n~~~shell\r\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n![image-20210523182426404](img/image-20210523182426404.png)\r\n\r\n**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.5 查看jar包内容\r\n\r\n~~~shell\r\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n# 3. 小结\r\n\r\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\r\n2. 通过修改配置文件，更改端口号\r\n3. 编写了测试用例\r\n4. 打包jar包运行\r\n\r\n', '<h2>2018-01-04</h2>\n<pre><code class=\"lang-\"># 使用vue的Webpack模板生成脚手架\n</code></pre>\n<h2>2018-01-05</h2>\n<pre><code class=\"lang-\"># 引入ElementUI\n\n# babel-plugin-component自定义主题\n# 首页\n# 登陆页\n# 注册页面\n# 日志页\n</code></pre>\n<h2>2018-01-07</h2>\n<pre><code class=\"lang-\"># 调整底部栏始终固定在底部\n# 日志页 添加时间轴\n# 首页的文章列表\n</code></pre>\n<h2>2018-01-08</h2>\n<pre><code class=\"lang-\"># 使用组件-博客作者tab页 \n# 添加第三方图标\n</code></pre>\n<h2>2018-01-09</h2>\n<pre><code class=\"lang-\"># 调整顶部导航栏：激活文字颜色，click点击\n# 组件-最新文章tab页\n\n# 最新文章、最热文章使用相同组件\n# 底部栏设计\n# 页面与两边边距改为100\n</code></pre>\n<h2>2018-01-10</h2>\n<pre><code class=\"lang-\"># 写博客 引入mavonEditor编辑器\n# 顶部导航栏都放入一个Menu中\n# 写文章页面\n#　mavonEditor局部引入\n\n#　页面的中间区域固定宽度，自动居中\n# 发布和取消\n# 发布dialog\n\n</code></pre>\n<h2>2018-01-11</h2>\n<pre><code class=\"lang-\"># 文章组件用守卫来改变body背景色\n# 调整登陆和注册页面，使其居中\n\n#子页面调整根元素为div\n#文章详情页\n\n</code></pre>\n<h2>2018-01-12</h2>\n<pre><code class=\"lang-\"># 文章详情页  内容  评论等\n\n</code></pre>\n<h2>2018-01-13</h2>\n<pre><code class=\"lang-\">## 重新调整页面结构	\n#顶部和底部 抽成  BaseHeader BaseFooter 组件\n#BlogView为单独页，以前是Home的子路由\n\n</code></pre>\n<h2>2018-01-15</h2>\n<pre><code class=\"lang-\"># 文章分类去掉子级\n# 将首页的文章列表抽成 ArticleItem组件\n# 增加文章的评论展示\n# 增加文章分类、标签页\n\n</code></pre>\n<h2>2018-01-15  2</h2>\n<pre><code class=\"lang-\"># 回到顶部去掉过渡动画（影响顶部导航栏）\n# 顶部导航栏 增加登录后菜单\n# 首页增加 最热标签\n# 增加 文章分类 标签的详情页\n# 将文章详情页、 文章分类标签页 改为Home的子路由（以前单独页）\n# Home组件增加路由判断：更正导航栏的状态、条件显示底部栏\n\n</code></pre>\n<h2>2018-01-16</h2>\n<pre><code class=\"lang-\"># 将写文章的顶部Header合并到BaseHeader中\n# 图片都放到了static目录下\n\n</code></pre>\n<h2>2018-01-24</h2>\n<pre><code class=\"lang-\"># 将自定义的theme放到assets下\n# 加入axios\n# 加入vuex\n# 实现登录\n# 实现退出\n\n</code></pre>\n<h2>2018-01-25</h2>\n<pre><code class=\"lang-\"># 实现注册逻辑\n# 写文章功能实现\n# 写文章时支持插入图片\n\n</code></pre>\n<h2>2018-01-26</h2>\n<pre><code class=\"lang-\"># 引入lodash工具类\n# 优化写文章的工具栏：滚动时固定顶部\n# 写文章 后台获取文章分类和标签\n\n# 首页的文章列表\n\n</code></pre>\n<h2>2018-01-27</h2>\n<pre><code class=\"lang-\"># 修改首页文章列表的样式\n# 首页加载文章功能\n# 文章查看功能\n# 文章分类和标签功能列表\n\n</code></pre>\n<h2>2018-01-28</h2>\n<pre><code class=\"lang-\"># 文章分类和标签详情\n\n</code></pre>\n<h2>2018-01-29</h2>\n<pre><code class=\"lang-\"># 文章分类和标签的文章数\n# 首页最热文章\n# 首页最新文章\n# 首页最热标签\n\n</code></pre>\n<h2>2018-01-30</h2>\n<pre><code class=\"lang-\"># BaseHeader放回views中\n# 修改Axios后置拦截，全局处理错误\n# 将登录 退出 和头像 放到一起\n\n</code></pre>\n', 1);
INSERT INTO `ms_article_body` VALUES (20, 'Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。\n如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。\n\n# 起步\n\n> 官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。\n\n尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：\n\n```javascript\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n\n```\n安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。\n\n# 声明式渲染\nVue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：\n```javascript\n<div id=\"app\">\n  {{ message }}\n</div>\n\n```\n```javascript\nvar app = new Vue({\n  el: \'#app\',\n  data: {\n    message: \'Hello Vue!\'\n  }\n})\n\n```\n我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。\n\n除了文本插值，我们还可以像这样来绑定元素特性：\n\n\n\n\n\n\n', '<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<p>如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。<br />\n如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。</p>\n<h1>起步</h1>\n<blockquote>\n<p>官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。</p>\n</blockquote>\n<p>尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;script src=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n\n</code></div></pre>\n<p>安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。</p>\n<h1>声明式渲染</h1>\n<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;div id=<span class=\"hljs-string\">\"app\"</span>&gt;\n  {{ message }}\n&lt;<span class=\"hljs-regexp\">/div&gt;\n\n</span></code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app\'</span>,\n  <span class=\"hljs-attr\">data</span>: {\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">\'Hello Vue!\'</span>\n  }\n})\n\n</code></div></pre>\n<p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。</p>\n<p>除了文本插值，我们还可以像这样来绑定元素特性：</p>\n', 9);
INSERT INTO `ms_article_body` VALUES (21, '## 快速上手\n\n本节将介绍如何在项目中使用 Element。\n\n### 使用 Starter Kit\n我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。\n\n如果不希望使用我们提供的模板，请继续阅读。\n\n### 使用 vue-cli\n\n我们还可以使用 vue-cli 初始化项目，命令如下：\n\n```language\n> npm i -g vue-cli\n> mkdir my-project && cd my-project\n> vue init webpack\n> npm i && npm i element-ui\n```\n\n### 引入 Element\n你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。\n\n#### 完整引入\n在 main.js 中写入以下内容：\n```javascript\nimport Vue from \'vue\'\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nimport App from \'./App.vue\'\n\nVue.use(ElementUI)\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App)\n})\n\n```\n以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。\n\n#### 按需引入\n借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。\n\n首先，安装 babel-plugin-component：\n\n', '<h2>快速上手</h2>\n<p>本节将介绍如何在项目中使用 Element。</p>\n<h3>使用 Starter Kit</h3>\n<p>我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。</p>\n<p>如果不希望使用我们提供的模板，请继续阅读。</p>\n<h3>使用 vue-cli</h3>\n<p>我们还可以使用 vue-cli 初始化项目，命令如下：</p>\n<pre><code class=\"lang-language\">&gt; npm i -g vue-cli\n&gt; mkdir my-project &amp;&amp; cd my-project\n&gt; vue init webpack\n&gt; npm i &amp;&amp; npm i element-ui\n</code></pre>\n<h3>引入 Element</h3>\n<p>你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。</p>\n<h4>完整引入</h4>\n<p>在 main.js 中写入以下内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n<span class=\"hljs-keyword\">import</span> ElementUI <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'element-ui\'</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\'element-ui/lib/theme-chalk/index.css\'</span>\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'./App.vue\'</span>\n\nVue.use(ElementUI)\n\n<span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app\'</span>,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">h</span> =&gt;</span> h(App)\n})\n\n</code></div></pre>\n<p>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</p>\n<h4>按需引入</h4>\n<p>借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。</p>\n<p>首先，安装 babel-plugin-component：</p>\n', 10);
INSERT INTO `ms_article_body` VALUES (1405916999854342146, '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image20210523173712142.png](https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image20210523174011613.png](https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png)\n\n此时的项目结构为：\n\n![image20210523174032053.png](https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image20210523181737720.png](https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image20210523182426404.png](https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png\" alt=\"image20210523173712142.png\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png\" alt=\"image20210523174011613.png\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png\" alt=\"image20210523174032053.png\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png\" alt=\"image20210523181737720.png\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png\" alt=\"image20210523182426404.png\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', 1405916999732707300);
INSERT INTO `ms_article_body` VALUES (1427273234843181058, '## RPC介绍\nRemote Procedure Call 远程过程调用，是分布式架构的核心，按响应方式分如下两种：\n​	同步调用：客户端调用服务方方法，等待直到服务方返回结果或者超时，再继续自己的操作。\n​	异步调用：客户端把消息发送给中间件，不再等待服务端返回，直接继续自己的操作。\n- 是一种进程间的通信方式\n\n- 它允许应用程序调用网络上的另一个应用程序中的方法\n\n- 对于服务的消费者而言，无需了解远程调用的底层细节，是透明的需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。\n\nRPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo、spring Cloud(restapi http)等。\n一台电脑调用另外一台脑上的方法\n## RPC组件\n简单来说一个RPC架构里包含如下4个组件:\n1、 客户端(Client)：服务调用者\n\n2、 客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数打包成网络消息，再通过网络发送给服务方\n\n3、 服务端存根(Server Stub)：接受客户端发送过来的消息并解包，再调用本地服务\n\n4、 服务端(Server)：服务提供者。\n![1562656624997.png](http://qxx33orzv.hb-bkt.clouddn.com/7ace2f8a-2df4-4871-8c28-c73818728ab6.png)\n##  RPC调用\n![1562656641829.png](http://qxx33orzv.hb-bkt.clouddn.com/7210706c-388a-4c7b-aee7-d0c69ef29be1.png)\n1、 服务调用方（client）调用以本地调用方式调用服务；\n\n2、 client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体\n\n​        在Java里就是序列化的过程\n\n3、 client stub找到服务地址，并将消息通过网络发送到服务端；\n\n4、 server stub收到消息后进行解码,在Java里就是反序列化的过程；\n\n5、 server stub根据解码结果调用本地的服务；\n\n6、 本地服务执行处理逻辑；\n\n7、 本地服务将结果返回给server stub；\n\n8、 server stub将返回结果打包成消息，Java里的序列化；\n\n9、 server stub将打包后的消息通过网络并发送至消费方；\n\n10、 client stub接收到消息，并进行解码, Java里的反序列化；\n\n11、 服务调用方（client）得到最终结果。\n\n## 总结：\n1：RPC  远程过程调用  调用另一个应用的方法\n\n2：RPC组件及调用过程\n\n客户端->客户端存根->服务端存根->服务端->服务端存根->客户端存根->客户端\n\n3：调用方式  接口调用 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '<h2><a id=\"RPC_0\"></a>RPC介绍</h2>\n<p>Remote Procedure Call 远程过程调用，是分布式架构的核心，按响应方式分如下两种：<br />\n​	同步调用：客户端调用服务方方法，等待直到服务方返回结果或者超时，再继续自己的操作。<br />\n​	异步调用：客户端把消息发送给中间件，不再等待服务端返回，直接继续自己的操作。</p>\n<ul>\n<li>\n<p>是一种进程间的通信方式</p>\n</li>\n<li>\n<p>它允许应用程序调用网络上的另一个应用程序中的方法</p>\n</li>\n<li>\n<p>对于服务的消费者而言，无需了解远程调用的底层细节，是透明的需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。</p>\n</li>\n</ul>\n<p>RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo、spring Cloud(restapi http)等。<br />\n一台电脑调用另外一台脑上的方法</p>\n<h2><a id=\"RPC_12\"></a>RPC组件</h2>\n<p>简单来说一个RPC架构里包含如下4个组件:<br />\n1、 客户端(Client)：服务调用者</p>\n<p>2、 客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数打包成网络消息，再通过网络发送给服务方</p>\n<p>3、 服务端存根(Server Stub)：接受客户端发送过来的消息并解包，再调用本地服务</p>\n<p>4、 服务端(Server)：服务提供者。<br />\n<img src=\"http://qxx33orzv.hb-bkt.clouddn.com/7ace2f8a-2df4-4871-8c28-c73818728ab6.png\" alt=\"1562656624997.png\" /></p>\n<h2><a id=\"RPC_22\"></a>RPC调用</h2>\n<p><img src=\"http://qxx33orzv.hb-bkt.clouddn.com/7210706c-388a-4c7b-aee7-d0c69ef29be1.png\" alt=\"1562656641829.png\" /><br />\n1、 服务调用方（client）调用以本地调用方式调用服务；</p>\n<p>2、 client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体</p>\n<p>​        在Java里就是序列化的过程</p>\n<p>3、 client stub找到服务地址，并将消息通过网络发送到服务端；</p>\n<p>4、 server stub收到消息后进行解码,在Java里就是反序列化的过程；</p>\n<p>5、 server stub根据解码结果调用本地的服务；</p>\n<p>6、 本地服务执行处理逻辑；</p>\n<p>7、 本地服务将结果返回给server stub；</p>\n<p>8、 server stub将返回结果打包成消息，Java里的序列化；</p>\n<p>9、 server stub将打包后的消息通过网络并发送至消费方；</p>\n<p>10、 client stub接收到消息，并进行解码, Java里的反序列化；</p>\n<p>11、 服务调用方（client）得到最终结果。</p>\n<h2><a id=\"_48\"></a>总结：</h2>\n<p>1：RPC  远程过程调用  调用另一个应用的方法</p>\n<p>2：RPC组件及调用过程</p>\n<p>客户端-&gt;客户端存根-&gt;服务端存根-&gt;服务端-&gt;服务端存根-&gt;客户端存根-&gt;客户端</p>\n<p>3：调用方式  接口调用</p>\n', 1427273234172092417);
INSERT INTO `ms_article_body` VALUES (1427276446841208833, '## Dubbo简介\nApache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。\n\nDubbo官网地址：http://dubbo.apache.org\n\nDubbo提供了三大核心能力：面向【接口】的远程方法调用，智能容错和负载均衡，以及服务自动注册（dubbo帮你注册在zookeeper创建节点数据）和发现(订阅 watch, dubbo帮我们做了)。\n\n## Dubbo架构\nDubbo架构图（Dubbo官方提供）如下：\n![1562888790694.png](http://qxx33orzv.hb-bkt.clouddn.com/ed1a1870-6f34-4bfa-81b5-3495cebd6b8c.png)\n节点角色说明：\n| 节点      | 角色名称                               |\n| --------- | -------------------------------------- |\n| Provider  | 暴露服务的服务提供方  服务方           |\n| Consumer  | 调用远程服务的服务消费方  调用方       |\n| Registry  | 服务注册与发现的注册中心               |\n| Monitor   | 统计服务的调用次数和调用时间的监控中心 |\n| Container | 服务运行容器                           |\n\n虚线都是异步访问，实线都是同步访问\n蓝色虚线:在启动时完成的功能\n红色虚线(实线)都是程序运行过程中执行的功能\n\n#### 调用关系说明:\n\n0. 服务容器负责启动，加载，运行服务提供者。\n\n1. 服务提供者在启动时，向注册中心注册自己提供的服务。\n2. 服务消费者在启动时，向注册中心订阅自己所需的服务。\n3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送通知消费者。\n4. 服务消费者，从注册中心摘取服务提供者列表，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n#### 什么是长连接？\n\n![21.png](http://qxx33orzv.hb-bkt.clouddn.com/d5ab0619-372d-4aa5-91f4-3053f44c9da3.png)\n\n## 总结：\n1：dubbo 远程调用框架 RPC, alibaba>apache(2019 2020)，服务注册与发现(订阅)，调用\n\n2：dubbo架构\n\n* 成员  注册中心， 服务提供者， 消费者， 监控中心\n* 工作流程: 启动时服务提供与消费者都注册到注册中心，消费监听注册中心中的服务，消费者获得提供者列表，提供者发生变化时会通知消费者更新列表，调用提供者。调用的过程信息每间隔一段时间就发送给监控中心记录下来\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '<h2><a id=\"Dubbo_0\"></a>Dubbo简介</h2>\n<p>Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。</p>\n<p>Dubbo官网地址：http://dubbo.apache.org</p>\n<p>Dubbo提供了三大核心能力：面向【接口】的远程方法调用，智能容错和负载均衡，以及服务自动注册（dubbo帮你注册在zookeeper创建节点数据）和发现(订阅 watch, dubbo帮我们做了)。</p>\n<h2><a id=\"Dubbo_7\"></a>Dubbo架构</h2>\n<p>Dubbo架构图（Dubbo官方提供）如下：<br />\n<img src=\"http://qxx33orzv.hb-bkt.clouddn.com/ed1a1870-6f34-4bfa-81b5-3495cebd6b8c.png\" alt=\"1562888790694.png\" /><br />\n节点角色说明：</p>\n<table>\n<thead>\n<tr>\n<th>节点</th>\n<th>角色名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Provider</td>\n<td>暴露服务的服务提供方  服务方</td>\n</tr>\n<tr>\n<td>Consumer</td>\n<td>调用远程服务的服务消费方  调用方</td>\n</tr>\n<tr>\n<td>Registry</td>\n<td>服务注册与发现的注册中心</td>\n</tr>\n<tr>\n<td>Monitor</td>\n<td>统计服务的调用次数和调用时间的监控中心</td>\n</tr>\n<tr>\n<td>Container</td>\n<td>服务运行容器</td>\n</tr>\n</tbody>\n</table>\n<p>虚线都是异步访问，实线都是同步访问<br />\n蓝色虚线:在启动时完成的功能<br />\n红色虚线(实线)都是程序运行过程中执行的功能</p>\n<h4><a id=\"_23\"></a>调用关系说明:</h4>\n<ol start=\"0\">\n<li>\n<p>服务容器负责启动，加载，运行服务提供者。</p>\n</li>\n<li>\n<p>服务提供者在启动时，向注册中心注册自己提供的服务。</p>\n</li>\n<li>\n<p>服务消费者在启动时，向注册中心订阅自己所需的服务。</p>\n</li>\n<li>\n<p>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送通知消费者。</p>\n</li>\n<li>\n<p>服务消费者，从注册中心摘取服务提供者列表，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>\n</li>\n<li>\n<p>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>\n</li>\n</ol>\n<h4><a id=\"_33\"></a>什么是长连接？</h4>\n<p><img src=\"http://qxx33orzv.hb-bkt.clouddn.com/d5ab0619-372d-4aa5-91f4-3053f44c9da3.png\" alt=\"21.png\" /></p>\n<h2><a id=\"_37\"></a>总结：</h2>\n<p>1：dubbo 远程调用框架 RPC, alibaba&gt;apache(2019 2020)，服务注册与发现(订阅)，调用</p>\n<p>2：dubbo架构</p>\n<ul>\n<li>成员  注册中心， 服务提供者， 消费者， 监控中心</li>\n<li>工作流程: 启动时服务提供与消费者都注册到注册中心，消费监听注册中心中的服务，消费者获得提供者列表，提供者发生变化时会通知消费者更新列表，调用提供者。调用的过程信息每间隔一段时间就发送给监控中心记录下来</li>\n</ul>\n', 1427276445754884097);
INSERT INTO `ms_article_body` VALUES (1427278901641510913, '## Docker常用命令\n\n\n\n\n### 一、Docker基本操作\n\n> Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的(如果非要使用CentOS的话建议最好7.x或以上版本)。\n\n\n\n使用yum命令在线安装：\n\n```shell\n yum -y install docker\n```\n\n\n查看Docker的版本：\n\n```shell\ndocker -v\n```\n\n\nDocker的启用和停止：\n```java\n启动docker：systemctl start docker\n停止docker：systemctl stop docker\n重启docker：systemctl restart docker\n查看docker状态：systemctl status docker\n开机启动：systemctl enable docker\n查看docker概要信息：docker info\n查看docker帮助文档：docker --help\n//PS:systemctl命令是系统服务管理器指令，它是 service 和 chkconfig 两个命令组合。\n```\n\n\n\n### 二、Docker镜像操作\n\n> Docker镜像是由文件系统叠加而成（是一种文件的存储形式）。最底端是一个文件引导系统，即bootfs，这很像典型的Linux/Unix的引导文件系统。Docker用户几乎永远不会和引导系统有什么交互。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要的一些文件，而这些文件就可以称为Docker镜像。\n\n\n\n##### 列出镜像：\n\n```shell\ndocker images\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210626123004618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTYyNjQzNQ==,size_16,color_FFFFFF,t_70)\n\n> 含义：\n	REPOSITORY：镜像所在的仓库名称\n	TAG：镜像标签\n	IMAGE ID：镜像ID\n	CREATED：镜像的创建日期（不是获取该镜像的日期）\n	SIZE：镜像大小\n	这些镜像都是存储在Docker宿主机的/var/lib/docker目录下\n\n\n\n##### 运行镜像：\n\n```shell\ndocker run --name 标签名字 –i –t 镜像所在仓库名称 /bin/bash\n```\n例如：\n\n>docker run --name custom_container_name –i –t docker.io/ubunto:12.04 /bin/bash\n表明从镜像Ubuntu:12.04启动一个容器，而这个镜像的操作系统就是Ubuntu:12.04。在构建容器时指定仓库的标签为custom_container_name 。\n\n\n\n##### 搜索镜像：\n\n```shell\ndocker search 镜像名称\n```\n例如\n\n> docker search tomcat\n\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210626123736958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTYyNjQzNQ==,size_16,color_FFFFFF,t_70)\n\n> 含义：\n> 	NAME：仓库名称\n	DESCRIPTION：镜像描述\n	STARS：用户评价，反应一个镜像的受欢迎程度\n	OFFICIAL：是否官方\n	AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的\n\n\n\n##### 拉取镜像\n```shell\ndocker pull 镜像名称[:版本号]\n# 例如: docker pull centos:7\n```\n\n\n\n\n**注意：**\n\n> 镜像仓库：[https://hub.docker.com/](https://hub.docker.com/)\n> 目前国内访问docker hub速度上有点尴尬，推荐使用docker Mirror。现有国内提供docker镜像加速服务的商家有不少，下面说一下ustc镜像。\n\n> ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。\n> 地址：[https://mirrors.ustc.edu.cn/help/](https://mirrors.ustc.edu.cn/help/)\n\n使用ustc镜像步骤：\n**（1）** 编辑该文件：vi /etc/docker/daemon.json  \n		PS: 如果该文件不存在就手动创建；另外有可能如果没有vim 命令则使用vi命令即可。\n\n**（2）** 在该文件中输入如下内容：\n\n```json\n{\n	\"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]\n}\n```\n还有本地阿里云的镜像地址,速度更快\n\n```json\n{ \n\"registry-mirrors\": [\"https://alzgoonw.mirror.aliyuncs.com\"] \n}\n```\n**（3）** 注意：一定要重启docker服务，如果重启docker后无法加速，可以重新启动OS ,然后通过docker pull命令下载镜像 。\n\n```shell\nservice docker restart\n```\n\n\n##### 删除镜像\n方式一：根据仓库的名称（镜像的名称）来删除 还可以使用image_id来进行删除。\n\n```shell\n删除指定镜像：\ndocker rmi 镜像ID\n```\n\n方式二：\n\n```shell\n删除所有镜像：\ndocker rmi `docker images -q`\n```\n\n### 三、Docker容器操作\n\n##### 查看容器\n查看正在运行容器\n\n```shell\ndocker ps\n```\n查看所有的容器（启动过的历史容器）\n\n```shell\ndocker ps –a\n```\n查看最后一次运行的容器：\n\n```shell\ndocker ps -l\n```\n查看停止的容器\n\n```shell\ndocker ps -f status=exited\n```\n\n\n\n##### 创建与启动容器\n\n```shell\ndocker run\n```\n\n> 创建容器常用的参数说明：\n  -i：表示运行容器\n  -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。\n  --name :为创建的容器命名。（前面是两个-）\n  -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。\n  -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。\n  -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个－p做多个端口映射\n\n例如：\n\n> 创建一个交互式容器并取名为mycentos\n> docker run -it --name=mycentos centos:7 /bin/bash\n> \n> 创建一个守护式容器\n> docker run -di --name=mycentos2 centos:7\n>**PS：守护式进程 exit退出时，容器不会停止**\n\n\n\n\n##### 登录守护式容器：\n```shell\ndocker exec -it  container_name (或者container_id)  /bin/bash\n#例如: docker exec -it mycentos2 /bin/bash\n```\n\n\n\n##### 退出当前容器：\n\n```shell\nexit\n```\n\n\n\n##### 停止与启动容器\n停止正在运行的容器：\n\n```shell\ndocker stop $CONTAINER_NAME/ID\n# 例如：docker stop mycentos2\n```\n\n\n\n启动已运行过的容器：\n```shell\ndocker start $CONTAINER_NAME/ID\n#例如：docker start mycentos2\n```\n\n\n\n##### 文件拷贝\n将文件拷贝到容器内：\n\n```java\ndocker cp 需要拷贝的文件或目录 容器名称:容器目录\n```\n\n将文件从容器内拷贝出来：\n```java\ndocker cp 容器名称:容器目录 需要拷贝的文件或目录\n```\n\n##### 目录挂载（映射）\n> 我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器里所对应的目录。\n\n```shell\n创建容器 添加-v参数 后边为   宿主机目录:容器目录\n```\n\n>例如：创建容器 并挂载宿主机目录 到容器中的目录下：\n>docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7\n>PS：如果共享的是多级的目录，可能会出现权限不足的提示。需要添加参数--privileged=true来解决挂载的目录没有权限的问题。\n>docker run -di --privileged=true -v /root/test:/usr/local/test --name=mycentos4 centos:7\n\n\n##### 查看容器IP地址：\n查看容器运行的各种数据\n\n```shell\ndocker inspect 容器名\n#例如：docker inspect mycentos2\n```\n直接输出IP地址\n\n```shell\ndocker inspect --format=\'{{.NetworkSettings.IPAddress}}\' 容器名\n# 例如: docker inspect --format=\'{{.NetworkSettings.IPAddress}}\' mycentos2\n```\n\n\n##### 删除容器\n删除指定的容器：\n\n```shell\ndocker rm $CONTAINER_ID/NAME\n# 这个命令只能删除已经关闭的容器，不能删除正在运行的容器\n```\n\n删除所有的容器：\n```shell\ndocker rm `docker ps -a -q`\n#或者：\ndocker rm $(docker ps -aq)\n```\n\n\n\n### 四、部署应用\n##### 部署MySQL\n拉取MySQL镜像(以5.7版本为例)\n\n```shell\ndocker pull mysql:5.7\n```\n创建MySQL容器\n\n```shell\ndocker run -di --name=my_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\n```\n\n进入MySQL容器\n\n```powershell\ndocker exec -it pinyougou_mysql /bin/bash\n```\n\n登录mysql\n\n```powershell\nmysql -u root -p\n```\n\n**授权允许远程登录**\n\n```powershell\nGRANT ALL PRIVILEGES ON *.* TO \'root\'@\'%\' IDENTIFIED BY \'123456\' WITH GRANT OPTION;\n#其中如果指定远程某个IP登录的话只需要把%换成指定的IP地址即可\n```\n\n\n\n##### tomcat部署\n拉取tomcat镜像\n\n```powershell\ndocker pull tomcat:7-jre8\n```\n\n创建tomcat容器\n\n```powershell\ndocker run -di --name=my_tomcat -p 9100:8080 tomcat:7-jre8\n```\n\n\n##### Nginx部署\n拉取Nginx镜像\n\n```powershell\ndocker pull nginx\n```\n创建Nginx容器\n\n```powershell\ndocker run -di --name=pinyougou_nginx -p 80:80  nginx \n```\n\n\n\n##### Redis部署\n拉取Redis镜像\n\n```powershell\ndocker pull redis\n```\n\n创建Redis容器\n\n```powershell\ndocker run -di --name=pinyougou_redis -p 6379:6379 redis\n```\n......\n==还有很多部署步骤类似就不一个一个写了~==\n\n\n\n### 五、备分与迁移\n\n##### 将容器保存为镜像\n```powershell\ndocker commit my_nginx mynginx\n#my_nginx是容器名称\n#mynginx是新的镜像名称\n#此镜像的内容就是你当前容器的内容，接下来你可以用此镜像再次运行新的容器\n```\n\n\n\n\n##### 镜像备份\n\n```powershell\ndocker  save -o mynginx.tar mynginx\n#-o 输出到的文件\n#执行后，运行ls命令即可看到打成的tar包.\n```\n\n\n##### 镜像恢复与迁移\n\n```powershell\ndocker load -i mynginx.tar\n#-i 输入的文件\n```\n\n\n**其它资源：**\n\nDocker官网：[http://www.docker.com](http://www.docker.com)\n\nDocker中文社区：[https://www.docker.org.cn/](https://www.docker.org.cn/)\n\nDocker中文文档：[http://www.dockerinfo.net/document](http://www.dockerinfo.net/document)', '<h2><a id=\"Docker_0\"></a>Docker常用命令</h2>\n<h3><a id=\"Docker_5\"></a>一、Docker基本操作</h3>\n<blockquote>\n<p>Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的(如果非要使用CentOS的话建议最好7.x或以上版本)。</p>\n</blockquote>\n<p>使用yum命令在线安装：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\"> yum -y install docker\n</code></div></pre>\n<p>查看Docker的版本：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker -v\n</code></div></pre>\n<p>Docker的启用和停止：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">启动docker：systemctl start docker\n停止docker：systemctl stop docker\n重启docker：systemctl restart docker\n查看docker状态：systemctl status docker\n开机启动：systemctl enable docker\n查看docker概要信息：docker info\n查看docker帮助文档：docker --help\n<span class=\"hljs-comment\">//PS:systemctl命令是系统服务管理器指令，它是 service 和 chkconfig 两个命令组合。</span>\n</code></div></pre>\n<h3><a id=\"Docker_39\"></a>二、Docker镜像操作</h3>\n<blockquote>\n<p>Docker镜像是由文件系统叠加而成（是一种文件的存储形式）。最底端是一个文件引导系统，即bootfs，这很像典型的Linux/Unix的引导文件系统。Docker用户几乎永远不会和引导系统有什么交互。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要的一些文件，而这些文件就可以称为Docker镜像。</p>\n</blockquote>\n<h5><a id=\"_45\"></a>列出镜像：</h5>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker images\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20210626123004618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTYyNjQzNQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>含义：<br />\n	REPOSITORY：镜像所在的仓库名称<br />\n	TAG：镜像标签<br />\n	IMAGE ID：镜像ID<br />\n	CREATED：镜像的创建日期（不是获取该镜像的日期）<br />\n	SIZE：镜像大小<br />\n	这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p>\n</blockquote>\n<h5><a id=\"_62\"></a>运行镜像：</h5>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker run --name 标签名字 –i –t 镜像所在仓库名称 /bin/bash\n</code></div></pre>\n<p>例如：</p>\n<blockquote>\n<p>docker run --name custom_container_name –i –t docker.io/ubunto:12.04 /bin/bash<br />\n表明从镜像Ubuntu:12.04启动一个容器，而这个镜像的操作系统就是Ubuntu:12.04。在构建容器时指定仓库的标签为custom_container_name 。</p>\n</blockquote>\n<h5><a id=\"_74\"></a>搜索镜像：</h5>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker search 镜像名称\n</code></div></pre>\n<p>例如</p>\n<blockquote>\n<p>docker search tomcat</p>\n</blockquote>\n<blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20210626123736958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTYyNjQzNQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<blockquote>\n<p>含义：<br />\n	NAME：仓库名称<br />\n	DESCRIPTION：镜像描述<br />\n	STARS：用户评价，反应一个镜像的受欢迎程度<br />\n	OFFICIAL：是否官方<br />\n	AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p>\n</blockquote>\n<h5><a id=\"_94\"></a>拉取镜像</h5>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker pull 镜像名称[:版本号]\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 例如: docker pull centos:7</span>\n</code></div></pre>\n<p><strong>注意：</strong></p>\n<blockquote>\n<p>镜像仓库：<a href=\"https://hub.docker.com/\" target=\"_blank\">https://hub.docker.com/</a><br />\n目前国内访问docker hub速度上有点尴尬，推荐使用docker Mirror。现有国内提供docker镜像加速服务的商家有不少，下面说一下ustc镜像。</p>\n</blockquote>\n<blockquote>\n<p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。<br />\n地址：<a href=\"https://mirrors.ustc.edu.cn/help/\" target=\"_blank\">https://mirrors.ustc.edu.cn/help/</a></p>\n</blockquote>\n<p>使用ustc镜像步骤：<br />\n<strong>（1）</strong> 编辑该文件：vi /etc/docker/daemon.json<br />\nPS: 如果该文件不存在就手动创建；另外有可能如果没有vim 命令则使用vi命令即可。</p>\n<p><strong>（2）</strong> 在该文件中输入如下内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-json\">{\n	<span class=\"hljs-attr\">\"registry-mirrors\"</span>: [<span class=\"hljs-string\">\"https://docker.mirrors.ustc.edu.cn\"</span>]\n}\n</code></div></pre>\n<p>还有本地阿里云的镜像地址,速度更快</p>\n<pre><div class=\"hljs\"><code class=\"lang-json\">{ \n<span class=\"hljs-attr\">\"registry-mirrors\"</span>: [<span class=\"hljs-string\">\"https://alzgoonw.mirror.aliyuncs.com\"</span>] \n}\n</code></div></pre>\n<p><strong>（3）</strong> 注意：一定要重启docker服务，如果重启docker后无法加速，可以重新启动OS ,然后通过docker pull命令下载镜像 。</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">service docker restart\n</code></div></pre>\n<h5><a id=\"_136\"></a>删除镜像</h5>\n<p>方式一：根据仓库的名称（镜像的名称）来删除 还可以使用image_id来进行删除。</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">删除指定镜像：\ndocker rmi 镜像ID\n</code></div></pre>\n<p>方式二：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">删除所有镜像：\ndocker rmi `docker images -q`\n</code></div></pre>\n<h3><a id=\"Docker_151\"></a>三、Docker容器操作</h3>\n<h5><a id=\"_153\"></a>查看容器</h5>\n<p>查看正在运行容器</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker ps\n</code></div></pre>\n<p>查看所有的容器（启动过的历史容器）</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker ps –a\n</code></div></pre>\n<p>查看最后一次运行的容器：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker ps -l\n</code></div></pre>\n<p>查看停止的容器</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker ps -f status=exited\n</code></div></pre>\n<h5><a id=\"_177\"></a>创建与启动容器</h5>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker run\n</code></div></pre>\n<blockquote>\n<p>创建容器常用的参数说明：<br />\n-i：表示运行容器<br />\n-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。<br />\n–name :为创建的容器命名。（前面是两个-）<br />\n-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。<br />\n-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。<br />\n-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个－p做多个端口映射</p>\n</blockquote>\n<p>例如：</p>\n<blockquote>\n<p>创建一个交互式容器并取名为mycentos<br />\ndocker run -it --name=mycentos centos:7 /bin/bash</p>\n<p>创建一个守护式容器<br />\ndocker run -di --name=mycentos2 centos:7<br />\n<strong>PS：守护式进程 exit退出时，容器不会停止</strong></p>\n</blockquote>\n<h5><a id=\"_203\"></a>登录守护式容器：</h5>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker exec -it  container_name (或者container_id)  /bin/bash\n<span class=\"hljs-meta\">#</span><span class=\"bash\">例如: docker <span class=\"hljs-built_in\">exec</span> -it mycentos2 /bin/bash</span>\n</code></div></pre>\n<h5><a id=\"_211\"></a>退出当前容器：</h5>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">exit\n</code></div></pre>\n<h5><a id=\"_219\"></a>停止与启动容器</h5>\n<p>停止正在运行的容器：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker stop $CONTAINER_NAME/ID\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 例如：docker stop mycentos2</span>\n</code></div></pre>\n<p>启动已运行过的容器：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker start $CONTAINER_NAME/ID\n<span class=\"hljs-meta\">#</span><span class=\"bash\">例如：docker start mycentos2</span>\n</code></div></pre>\n<h5><a id=\"_237\"></a>文件拷贝</h5>\n<p>将文件拷贝到容器内：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">docker cp 需要拷贝的文件或目录 容器名称:容器目录\n</code></div></pre>\n<p>将文件从容器内拷贝出来：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">docker cp 容器名称:容器目录 需要拷贝的文件或目录\n</code></div></pre>\n<h5><a id=\"_249\"></a>目录挂载（映射）</h5>\n<blockquote>\n<p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器里所对应的目录。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">创建容器 添加-v参数 后边为   宿主机目录:容器目录\n</code></div></pre>\n<blockquote>\n<p>例如：创建容器 并挂载宿主机目录 到容器中的目录下：<br />\ndocker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7<br />\nPS：如果共享的是多级的目录，可能会出现权限不足的提示。需要添加参数–privileged=true来解决挂载的目录没有权限的问题。<br />\ndocker run -di --privileged=true -v /root/test:/usr/local/test --name=mycentos4 centos:7</p>\n</blockquote>\n<h5><a id=\"IP_262\"></a>查看容器IP地址：</h5>\n<p>查看容器运行的各种数据</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker inspect 容器名\n<span class=\"hljs-meta\">#</span><span class=\"bash\">例如：docker inspect mycentos2</span>\n</code></div></pre>\n<p>直接输出IP地址</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker inspect --format=\'{{.NetworkSettings.IPAddress}}\' 容器名\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 例如: docker inspect --format=<span class=\"hljs-string\">\'{{.NetworkSettings.IPAddress}}\'</span> mycentos2</span>\n</code></div></pre>\n<h5><a id=\"_277\"></a>删除容器</h5>\n<p>删除指定的容器：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker rm $CONTAINER_ID/NAME\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 这个命令只能删除已经关闭的容器，不能删除正在运行的容器</span>\n</code></div></pre>\n<p>删除所有的容器：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker rm `docker ps -a -q`\n<span class=\"hljs-meta\">#</span><span class=\"bash\">或者：</span>\ndocker rm $(docker ps -aq)\n</code></div></pre>\n<h3><a id=\"_294\"></a>四、部署应用</h3>\n<h5><a id=\"MySQL_295\"></a>部署MySQL</h5>\n<p>拉取MySQL镜像(以5.7版本为例)</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker pull mysql:5.7\n</code></div></pre>\n<p>创建MySQL容器</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker run -di --name=my_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\n</code></div></pre>\n<p>进入MySQL容器</p>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">docker exec -it pinyougou_mysql /bin/bash\n</code></div></pre>\n<p>登录mysql</p>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">mysql -u root -p\n</code></div></pre>\n<p><strong>授权允许远程登录</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">GRANT ALL PRIVILEGES ON *.* TO <span class=\"hljs-string\">\'root\'</span><span class=\"hljs-string\">@\'%\' IDENTIFIED BY \'123456\' WITH GRANT OPTION;\n#其中如果指定远程某个IP登录的话只需要把%换成指定的IP地址即可\n</span></code></div></pre>\n<h5><a id=\"tomcat_328\"></a>tomcat部署</h5>\n<p>拉取tomcat镜像</p>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">docker pull tomcat:<span class=\"hljs-number\">7</span>-jre8\n</code></div></pre>\n<p>创建tomcat容器</p>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">docker run -di --name=my_tomcat -p <span class=\"hljs-number\">9100</span>:<span class=\"hljs-number\">8080</span> tomcat:<span class=\"hljs-number\">7</span>-jre8\n</code></div></pre>\n<h5><a id=\"Nginx_342\"></a>Nginx部署</h5>\n<p>拉取Nginx镜像</p>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">docker pull nginx\n</code></div></pre>\n<p>创建Nginx容器</p>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">docker run -di --name=pinyougou_nginx -p <span class=\"hljs-number\">80</span>:<span class=\"hljs-number\">80</span>  nginx \n</code></div></pre>\n<h5><a id=\"Redis_356\"></a>Redis部署</h5>\n<p>拉取Redis镜像</p>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">docker pull redis\n</code></div></pre>\n<p>创建Redis容器</p>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">docker run -di --name=pinyougou_redis -p <span class=\"hljs-number\">6379</span>:<span class=\"hljs-number\">6379</span> redis\n</code></div></pre>\n<p>…<br />\n<mark>还有很多部署步骤类似就不一个一个写了~</mark></p>\n<h3><a id=\"_373\"></a>五、备分与迁移</h3>\n<h5><a id=\"_375\"></a>将容器保存为镜像</h5>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">docker commit my_nginx mynginx\n<span class=\"hljs-comment\">#my_nginx是容器名称</span>\n<span class=\"hljs-comment\">#mynginx是新的镜像名称</span>\n<span class=\"hljs-comment\">#此镜像的内容就是你当前容器的内容，接下来你可以用此镜像再次运行新的容器</span>\n</code></div></pre>\n<h5><a id=\"_386\"></a>镜像备份</h5>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">docker  save -o mynginx.tar mynginx\n<span class=\"hljs-comment\">#-o 输出到的文件</span>\n<span class=\"hljs-comment\">#执行后，运行ls命令即可看到打成的tar包.</span>\n</code></div></pre>\n<h5><a id=\"_395\"></a>镜像恢复与迁移</h5>\n<pre><div class=\"hljs\"><code class=\"lang-powershell\">docker load -i mynginx.tar\n<span class=\"hljs-comment\">#-i 输入的文件</span>\n</code></div></pre>\n<p><strong>其它资源：</strong></p>\n<p>Docker官网：<a href=\"http://www.docker.com\" target=\"_blank\">http://www.docker.com</a></p>\n<p>Docker中文社区：<a href=\"https://www.docker.org.cn/\" target=\"_blank\">https://www.docker.org.cn/</a></p>\n<p>Docker中文文档：<a href=\"http://www.dockerinfo.net/document\" target=\"_blank\">http://www.dockerinfo.net/document</a></p>\n', 1427278899737296897);
INSERT INTO `ms_article_body` VALUES (1427491230954057729, '## FastDFS体系结构 \nFastDFS是一个开源的轻量级[分布式文件系统](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/1250388)，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。\n\nFastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。\n\nFastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文件上传、下载，通过Tracker server 调度最终由 Storage server 完成文件上传和下载。\n\nTracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，Storageserver 没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。可以将storage称为存储服务器。\n![1559117928459.png](http://qxx33orzv.hb-bkt.clouddn.com/e872f896-411c-4211-b323-e8eb672c861f.png)\n\n## 上传流程\n![1559117994668.png](http://qxx33orzv.hb-bkt.clouddn.com/60892e19-fa38-4834-a3a0-a456608e01f9.png)\n客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。\n![1559118013272.png](http://qxx33orzv.hb-bkt.clouddn.com/027af050-ebbc-4990-a02d-8c11393a0a3b.png)\n**组名**：文件上传后所在的 storage 组名称，在文件上传成功后有storage 服务器返回，需要客户端自行保存。\n\n**虚拟磁盘路径**：storage 配置的虚拟路径，与磁盘选项store_path*对应。如果配置了\n\nstore_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。\n\n**数据两级目录**：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据\n\n文件。\n\n**文件名**：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储\n\n服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。', '<h2><a id=\"FastDFS_0\"></a>FastDFS体系结构</h2>\n<p>FastDFS是一个开源的轻量级<a href=\"https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/1250388\" target=\"_blank\">分布式文件系统</a>，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p>\n<p>FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p>\n<p>FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文件上传、下载，通过Tracker server 调度最终由 Storage server 完成文件上传和下载。</p>\n<p>Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，Storageserver 没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。可以将storage称为存储服务器。<br />\n<img src=\"http://qxx33orzv.hb-bkt.clouddn.com/e872f896-411c-4211-b323-e8eb672c861f.png\" alt=\"1559117928459.png\" /></p>\n<h2><a id=\"_10\"></a>上传流程</h2>\n<p><img src=\"http://qxx33orzv.hb-bkt.clouddn.com/60892e19-fa38-4834-a3a0-a456608e01f9.png\" alt=\"1559117994668.png\" /><br />\n客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。<br />\n<img src=\"http://qxx33orzv.hb-bkt.clouddn.com/027af050-ebbc-4990-a02d-8c11393a0a3b.png\" alt=\"1559118013272.png\" /><br />\n<strong>组名</strong>：文件上传后所在的 storage 组名称，在文件上传成功后有storage 服务器返回，需要客户端自行保存。</p>\n<p><strong>虚拟磁盘路径</strong>：storage 配置的虚拟路径，与磁盘选项store_path*对应。如果配置了</p>\n<p>store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。</p>\n<p><strong>数据两级目录</strong>：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据</p>\n<p>文件。</p>\n<p><strong>文件名</strong>：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储</p>\n<p>服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</p>\n', 1427491228018044929);
INSERT INTO `ms_article_body` VALUES (1427510754017308673, '## lua是什么\nLua  是一个小巧的[脚本语言](https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80)。它是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo三人所组成的研究小组于1993年开发的。 其设计目的是为了通过灵活嵌入应用程序中从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。\n\n简单来说：\n\nLua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\n\n## 特性\n\n- 支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；\n- 自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；\n- 语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；\n- 通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。\n\n## 应用场景\n\n- 游戏开发\n- 独立应用脚本\n- Web 应用脚本\n- 扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench\n- 安全系统，如入侵检测系统\n- redis中嵌套调用实现类似事务的功能\n- web容器中应用处理一些过滤 缓存等等的逻辑，例如nginx。\n\n\n## LUA的基本语法\nlua有交互式编程和脚本式编程。\n\n交互式编程就是直接输入语法，就能执行。\n\n脚本式编程需要编写脚本，然后再执行命令 执行脚本才可以。\n\n一般采用脚本式编程。（例如：编写一个hello.lua的文件，输入文件内容，并执行lua hell.lua即可）\n\n#### (1)交互式编程\n\nLua 提供了交互式编程模式。我们可以在命令行中输入程序并立即查看效果。\n\nLua 交互式编程模式可以通过命令 lua -i 或 lua 来启用：\n~~~\nlua -i\n~~~\n\n\n#### (2)脚本式编程\n我们可以将 Lua 程序代码保持到一个以 lua 结尾的文件，并执行，该模式称为脚本式编程，例如上面入门程序中将lua语法写到hello.lua文件中。\n\n####  注释\n\n一行注释：两个减号是单行注释:\n\n```\n--\n```\n\n多行注释：\n\n```lua\n--[[\n 多行注释\n 多行注释\n --]]\n```\n\n\n\n#### 定义变量\n\n全局变量，默认的情况下，定义一个变量都是全局变量，\n\n如果要用局部变量 需要声明为local.例如：\n\n```lua\n-- 全局变量赋值\na=1\n-- 局部变量赋值\nlocal b=2 \n```\n\n如果变量没有初始化：则 它的值为nil 这和java中的null不同。\n\n\n\n\n#### Lua中的数据类型\n\nLua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\n\nLua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。\n\n| 数据类型 | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| nil      | 这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。 |\n| boolean  | 包含两个值：false和true。                                    |\n| number   | 表示双精度类型的实浮点数                                     |\n| string   | 字符串由一对双引号或单引号来表示                             |\n| function | 由 C 或 Lua 编写的函数                                       |\n| userdata | 表示任意存储在变量中的C数据结构                              |\n| thread   | 表示执行的独立线路，用于执行协同程序                         |\n| table    | Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表。 |\n\n实例：\n\n```properties\nprint(type(\"Hello world\"))      --> string\nprint(type(10.4*3))             --> number\nprint(type(print))              --> function\nprint(type(type))               --> function\nprint(type(true))               --> boolean\nprint(type(nil))                --> nil\n```\n\n\n\n\n\n#### 流程控制\n\n(1)if语句\n\nLua **if 语句** 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。\n\n语法：\n\n```properties\nif(布尔表达式)\nthen\n   --[ 在布尔表达式为 true 时执行的语句 --]\nend\n```\n\n\n\n(2)if..else语句\n\nLua if 语句可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码块。\n\n语法：\n\n```properties\nif(布尔表达式)\nthen\n   --[ 布尔表达式为 true 时执行该语句块 --]\nelse\n   --[ 布尔表达式为 false 时执行该语句块 --]\nend\n```\n\n\n\n#### 循环\n\n学员完成\n\n(1)while循环[==满足条件就循环==]\n\nLua 编程语言中 while 循环语句在判断条件为 true 时会重复执行循环体语句。\n语法：\n\n```properties\nwhile(condition)\ndo\n   statements\nend\n```\n\n实例：\n\n```properties\na=10\nwhile( a < 20 )\ndo\n   print(\"a 的值为:\", a)\n   a = a+1\nend\n```\n\n\n(2)for循环\n\nLua 编程语言中 for 循环语句可以重复执行指定语句，重复次数可在 for 语句中控制。\n\n语法：  1->10  1:exp1  10:exp2  2:exp3:递增的数量   \n\n```properties\nfor var=exp1,exp2,exp3 \ndo  \n    <执行体>  \nend  \n```\n\nvar 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 **\"执行体\"**。exp3 是可选的，如果不指定，默认为1。\n\n例子：\n\n```properties\nfor i=1,9,2\ndo\n   print(i)\nend\n```\n\n`for i=1,9,2`:i=1从1开始循环，9循环数据到9结束，2每次递增2\n\n\n(3)repeat...until语句[==满足条件结束==]\n\nLua 编程语言中 repeat...until 循环语句不同于 for 和 while循环，for 和 while 循环的条件语句在当前循环执行开始时判断，而 repeat...until 循环的条件语句在当前循环结束后判断。\n\n语法：\n\n```properties\nrepeat\n   statements\nuntil( condition )\n```\n\n\n\n#### 函数\n\nlua中也可以定义函数，类似于java中的方法。例如：\n\n```lua\n--[[ 函数返回两个值的最大值 --]]\nfunction max(num1, num2)\n\n   if (num1 > num2) then\n      result = num1;\n   else\n      result = num2;\n   end\n\n   return result; \nend\n-- 调用函数\nprint(\"两值比较最大值为 \",max(10,4))\nprint(\"两值比较最大值为 \",max(5,6))\n```\n\n执行之后的结果：\n\n```\n两值比较最大值为     10\n两值比较最大值为     6\n```\n\n\n\n..:表示拼接\n\n\n\n#### 表\n\ntable 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。\n\nLua也是通过table来解决模块（module）、包（package）和对象（Object）的。\n\n案例：\n\n```properties\n-- 初始化表\nmytable = {}\n\n-- 指定值\nmytable[1]= \"Lua\"\n\n-- 移除引用\nmytable = nil\n```\n\n\n\n#### 模块\n\n(1)模块定义\n\n模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\n\n创建一个文件叫module.lua，在module.lua中创建一个独立的模块，代码如下：\n\n```properties\n-- 文件名为 module.lua\n-- 定义一个名为 module 的模块\nmodule = {}\n \n-- 定义一个常量\nmodule.constant = \"这是一个常量\"\n \n-- 定义一个函数\nfunction module.func1()\n    print(\"这是一个公有函数\")\nend\n \nlocal function func2()\n    print(\"这是一个私有函数！\")\nend\n \nfunction module.func3()\n    func2()\nend\n \nreturn module\n```\n\n由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。\n\n上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用.\n\n\n\n(2)require 函数\n\nrequire 用于 引入其他的模块，类似于java中的类要引用别的类的效果。\n\n用法：\n\n```properties\nrequire(\"<模块名>\")\n```\n\n```properties\nrequire \"<模块名>\"\n```\n\n两种都可以。\n\n我们可以将上面定义的module模块引入使用,创建一个test_module.lua文件，代码如下：\n\n```properties\n-- test_module.lua 文件\n-- module 模块为上文提到到 module.lua\nrequire(\"module\")\n\nprint(module.constant)\n\nmodule.func3()\n```\n\n\n\n\n\n\n\n\n\n\n', '<h2><a id=\"lua_0\"></a>lua是什么</h2>\n<p>Lua  是一个小巧的<a href=\"https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80\" target=\"_blank\">脚本语言</a>。它是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo三人所组成的研究小组于1993年开发的。 其设计目的是为了通过灵活嵌入应用程序中从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。</p>\n<p>简单来说：</p>\n<p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>\n<h2><a id=\"_7\"></a>特性</h2>\n<ul>\n<li>支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；</li>\n<li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li>\n<li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li>\n<li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li>\n</ul>\n<h2><a id=\"_14\"></a>应用场景</h2>\n<ul>\n<li>游戏开发</li>\n<li>独立应用脚本</li>\n<li>Web 应用脚本</li>\n<li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li>\n<li>安全系统，如入侵检测系统</li>\n<li>redis中嵌套调用实现类似事务的功能</li>\n<li>web容器中应用处理一些过滤 缓存等等的逻辑，例如nginx。</li>\n</ul>\n<h2><a id=\"LUA_25\"></a>LUA的基本语法</h2>\n<p>lua有交互式编程和脚本式编程。</p>\n<p>交互式编程就是直接输入语法，就能执行。</p>\n<p>脚本式编程需要编写脚本，然后再执行命令 执行脚本才可以。</p>\n<p>一般采用脚本式编程。（例如：编写一个hello.lua的文件，输入文件内容，并执行lua hell.lua即可）</p>\n<h4><a id=\"1_34\"></a>(1)交互式编程</h4>\n<p>Lua 提供了交互式编程模式。我们可以在命令行中输入程序并立即查看效果。</p>\n<p>Lua 交互式编程模式可以通过命令 lua -i 或 lua 来启用：</p>\n<pre><code class=\"lang-\">lua -i\n</code></pre>\n<h4><a id=\"2_44\"></a>(2)脚本式编程</h4>\n<p>我们可以将 Lua 程序代码保持到一个以 lua 结尾的文件，并执行，该模式称为脚本式编程，例如上面入门程序中将lua语法写到hello.lua文件中。</p>\n<h4><a id=\"_47\"></a>注释</h4>\n<p>一行注释：两个减号是单行注释:</p>\n<pre><code class=\"lang-\">--\n</code></pre>\n<p>多行注释：</p>\n<pre><div class=\"hljs\"><code class=\"lang-lua\"><span class=\"hljs-comment\">--[[\n 多行注释\n 多行注释\n --]]</span>\n</code></div></pre>\n<h4><a id=\"_66\"></a>定义变量</h4>\n<p>全局变量，默认的情况下，定义一个变量都是全局变量，</p>\n<p>如果要用局部变量 需要声明为local.例如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-lua\"><span class=\"hljs-comment\">-- 全局变量赋值</span>\na=<span class=\"hljs-number\">1</span>\n<span class=\"hljs-comment\">-- 局部变量赋值</span>\n<span class=\"hljs-keyword\">local</span> b=<span class=\"hljs-number\">2</span> \n</code></div></pre>\n<p>如果变量没有初始化：则 它的值为nil 这和java中的null不同。</p>\n<h4><a id=\"Lua_84\"></a>Lua中的数据类型</h4>\n<p>Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p>\n<p>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nil</td>\n<td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>包含两个值：false和true。</td>\n</tr>\n<tr>\n<td>number</td>\n<td>表示双精度类型的实浮点数</td>\n</tr>\n<tr>\n<td>string</td>\n<td>字符串由一对双引号或单引号来表示</td>\n</tr>\n<tr>\n<td>function</td>\n<td>由 C 或 Lua 编写的函数</td>\n</tr>\n<tr>\n<td>userdata</td>\n<td>表示任意存储在变量中的C数据结构</td>\n</tr>\n<tr>\n<td>thread</td>\n<td>表示执行的独立线路，用于执行协同程序</td>\n</tr>\n<tr>\n<td>table</td>\n<td>Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表。</td>\n</tr>\n</tbody>\n</table>\n<p>实例：</p>\n<pre><code class=\"lang-properties\">print(type(&quot;Hello world&quot;))      --&gt; string\nprint(type(10.4*3))             --&gt; number\nprint(type(print))              --&gt; function\nprint(type(type))               --&gt; function\nprint(type(true))               --&gt; boolean\nprint(type(nil))                --&gt; nil\n</code></pre>\n<h4><a id=\"_116\"></a>流程控制</h4>\n<p>(1)if语句</p>\n<p>Lua <strong>if 语句</strong> 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。</p>\n<p>语法：</p>\n<pre><code class=\"lang-properties\">if(布尔表达式)\nthen\n   --[ 在布尔表达式为 true 时执行的语句 --]\nend\n</code></pre>\n<p>(2)if…else语句</p>\n<p>Lua if 语句可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码块。</p>\n<p>语法：</p>\n<pre><code class=\"lang-properties\">if(布尔表达式)\nthen\n   --[ 布尔表达式为 true 时执行该语句块 --]\nelse\n   --[ 布尔表达式为 false 时执行该语句块 --]\nend\n</code></pre>\n<h4><a id=\"_150\"></a>循环</h4>\n<p>学员完成</p>\n<p>(1)while循环[<mark>满足条件就循环</mark>]</p>\n<p>Lua 编程语言中 while 循环语句在判断条件为 true 时会重复执行循环体语句。<br />\n语法：</p>\n<pre><code class=\"lang-properties\">while(condition)\ndo\n   statements\nend\n</code></pre>\n<p>实例：</p>\n<pre><code class=\"lang-properties\">a=10\nwhile( a &lt; 20 )\ndo\n   print(&quot;a 的值为:&quot;, a)\n   a = a+1\nend\n</code></pre>\n<p>(2)for循环</p>\n<p>Lua 编程语言中 for 循环语句可以重复执行指定语句，重复次数可在 for 语句中控制。</p>\n<p>语法：  1-&gt;10  1:exp1  10:exp2  2:exp3:递增的数量</p>\n<pre><code class=\"lang-properties\">for var=exp1,exp2,exp3 \ndo  \n    &lt;执行体&gt;  \nend  \n</code></pre>\n<p>var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 <strong>“执行体”</strong>。exp3 是可选的，如果不指定，默认为1。</p>\n<p>例子：</p>\n<pre><code class=\"lang-properties\">for i=1,9,2\ndo\n   print(i)\nend\n</code></pre>\n<p><code>for i=1,9,2</code>:i=1从1开始循环，9循环数据到9结束，2每次递增2</p>\n<p>(3)repeat…until语句[<mark>满足条件结束</mark>]</p>\n<p>Lua 编程语言中 repeat…until 循环语句不同于 for 和 while循环，for 和 while 循环的条件语句在当前循环执行开始时判断，而 repeat…until 循环的条件语句在当前循环结束后判断。</p>\n<p>语法：</p>\n<pre><code class=\"lang-properties\">repeat\n   statements\nuntil( condition )\n</code></pre>\n<h4><a id=\"_219\"></a>函数</h4>\n<p>lua中也可以定义函数，类似于java中的方法。例如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-lua\"><span class=\"hljs-comment\">--[[ 函数返回两个值的最大值 --]]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(num1, num2)</span></span>\n\n   <span class=\"hljs-keyword\">if</span> (num1 &gt; num2) <span class=\"hljs-keyword\">then</span>\n      result = num1;\n   <span class=\"hljs-keyword\">else</span>\n      result = num2;\n   <span class=\"hljs-keyword\">end</span>\n\n   <span class=\"hljs-keyword\">return</span> result; \n<span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-comment\">-- 调用函数</span>\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"两值比较最大值为 \"</span>,<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">4</span>))\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"两值比较最大值为 \"</span>,<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>))\n</code></div></pre>\n<p>执行之后的结果：</p>\n<pre><code class=\"lang-\">两值比较最大值为     10\n两值比较最大值为     6\n</code></pre>\n<p>…:表示拼接</p>\n<h4><a id=\"_253\"></a>表</h4>\n<p>table 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。</p>\n<p>Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。</p>\n<p>案例：</p>\n<pre><code class=\"lang-properties\">-- 初始化表\nmytable = {}\n\n-- 指定值\nmytable[1]= &quot;Lua&quot;\n\n-- 移除引用\nmytable = nil\n</code></pre>\n<h4><a id=\"_274\"></a>模块</h4>\n<p>(1)模块定义</p>\n<p>模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p>\n<p>创建一个文件叫module.lua，在module.lua中创建一个独立的模块，代码如下：</p>\n<pre><code class=\"lang-properties\">-- 文件名为 module.lua\n-- 定义一个名为 module 的模块\nmodule = {}\n \n-- 定义一个常量\nmodule.constant = &quot;这是一个常量&quot;\n \n-- 定义一个函数\nfunction module.func1()\n    print(&quot;这是一个公有函数&quot;)\nend\n \nlocal function func2()\n    print(&quot;这是一个私有函数！&quot;)\nend\n \nfunction module.func3()\n    func2()\nend\n \nreturn module\n</code></pre>\n<p>由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。</p>\n<p>上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用.</p>\n<p>(2)require 函数</p>\n<p>require 用于 引入其他的模块，类似于java中的类要引用别的类的效果。</p>\n<p>用法：</p>\n<pre><code class=\"lang-properties\">require(&quot;&lt;模块名&gt;&quot;)\n</code></pre>\n<pre><code class=\"lang-properties\">require &quot;&lt;模块名&gt;&quot;\n</code></pre>\n<p>两种都可以。</p>\n<p>我们可以将上面定义的module模块引入使用,创建一个test_module.lua文件，代码如下：</p>\n<pre><code class=\"lang-properties\">-- test_module.lua 文件\n-- module 模块为上文提到到 module.lua\nrequire(&quot;module&quot;)\n\nprint(module.constant)\n\nmodule.func3()\n</code></pre>\n', 1427510750640893954);
INSERT INTO `ms_article_body` VALUES (1427644736361066497, 'Redis在使用过程中服务器毫无征兆的宕机，是一个麻烦的事情，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要哨兵和复制。\n\nSentinel（哨兵）可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能，\n\nReplication（复制）则是负责让一个Redis服务器可以配备多个备份的服务器。\n\nRedis也是利用这两个功能来保证Redis的高可用的\n\n##### Redis的主从复制实现高可用\n\n![1558592619048.png](http://qxx33orzv.hb-bkt.clouddn.com/61bd99bd-4177-4bb9-86db-a0ca32d85869.png)\n\n如图，通过主从架构，一个主节点，两个从节点。\n\n通过手动监控的方式，监控master的宕机，以及出现故障将故障转移的方式可以做到高可用。\n\n比如：如果主节点宕机，我们手动监控到主节点的宕机，并将某一个Slave变成主节点。 但是这样话，如何手动监控也是很麻烦的事情。所以使用sentinel机制就可以解决了这个问题，Sentinel（哨兵）是Redis 的高可用性解决方案。\n\n+ 它能自动进行故障转移。\n+ 客户端连接sentinel，不需要关系具体的master。\n+ 当master地址改变时由sentinel更新到客户端。\n\n![1558593335136.png](http://qxx33orzv.hb-bkt.clouddn.com/ee0cbd2e-8d18-4429-84a7-1937a39ecb99.png)\n\n架构原理如图：\n\n1.多个sentinel 发现并确认master有问题。\n\n2.sentinel内部选举领导\n\n3.选举出slave作为新的master\n\n4.通知其余的slave成为新master的slave\n\n5.通知客户端 主从变化\n\n6.如果老的master重新复活，那么成为新的master的slave\n\n\n\n要实现上边的功能的主要细节主要有以下三个定时任务：\n\n1. 每10秒，哨兵会向master和slave发送INFO命令(目的就是监控每一个节点信息)\n2. 每2秒，哨兵会向master库和slave的频道(__sentinel__:hello)发送自己的信息 （sentinel节点通过__sentinel__:hello频道进行信息交换，比如加入哨兵集群，分享自己节点数据）\n3. 每1秒，哨兵会向master和slave以及其他哨兵节点发送PING命令（目的就是 redis节点的状态监控，还有领导选举，主备切换选择等）\n\n\n\n策略总结：\n\n​	1.尽量为 每一个节点部署一个哨兵\n\n​	2.哨兵也要搭建集群（防止哨兵单点故障）\n\n​	3.每一个节点都同时设置quorum的值超过半数（N/2）+1\n\n\n\n面试常问的问题：\n\n​	主从复制，以及哨兵 和集群之间区别。\n\n主从复制 是redis实现高可用的一个策略。将会有主节点 和从节点，从节点的数据完整的从主节点中复制一份。\n\n哨兵：当系统节点异常宕机的时候，开发者可以手动进行故障转移恢复，但是手动比较麻烦，所以通过哨兵机制自动进行监控和恢复。为了解决哨兵也会单点故障的问题，可以建立哨兵集群。\n\n集群：即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据，浪费内存且有木桶效应。为了最大化利用内存，可以采用集群，就是分布式存储。这个时候可以使用redis集群。将不同的数据分配到不同的节点中，这样就可以横向扩展，扩容。\n\n', '<p>Redis在使用过程中服务器毫无征兆的宕机，是一个麻烦的事情，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要哨兵和复制。</p>\n<p>Sentinel（哨兵）可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能，</p>\n<p>Replication（复制）则是负责让一个Redis服务器可以配备多个备份的服务器。</p>\n<p>Redis也是利用这两个功能来保证Redis的高可用的</p>\n<h5><a id=\"Redis_8\"></a>Redis的主从复制实现高可用</h5>\n<p><img src=\"http://qxx33orzv.hb-bkt.clouddn.com/61bd99bd-4177-4bb9-86db-a0ca32d85869.png\" alt=\"1558592619048.png\" /></p>\n<p>如图，通过主从架构，一个主节点，两个从节点。</p>\n<p>通过手动监控的方式，监控master的宕机，以及出现故障将故障转移的方式可以做到高可用。</p>\n<p>比如：如果主节点宕机，我们手动监控到主节点的宕机，并将某一个Slave变成主节点。 但是这样话，如何手动监控也是很麻烦的事情。所以使用sentinel机制就可以解决了这个问题，Sentinel（哨兵）是Redis 的高可用性解决方案。</p>\n<ul>\n<li>它能自动进行故障转移。</li>\n<li>客户端连接sentinel，不需要关系具体的master。</li>\n<li>当master地址改变时由sentinel更新到客户端。</li>\n</ul>\n<p><img src=\"http://qxx33orzv.hb-bkt.clouddn.com/ee0cbd2e-8d18-4429-84a7-1937a39ecb99.png\" alt=\"1558593335136.png\" /></p>\n<p>架构原理如图：</p>\n<p>1.多个sentinel 发现并确认master有问题。</p>\n<p>2.sentinel内部选举领导</p>\n<p>3.选举出slave作为新的master</p>\n<p>4.通知其余的slave成为新master的slave</p>\n<p>5.通知客户端 主从变化</p>\n<p>6.如果老的master重新复活，那么成为新的master的slave</p>\n<p>要实现上边的功能的主要细节主要有以下三个定时任务：</p>\n<ol>\n<li>每10秒，哨兵会向master和slave发送INFO命令(目的就是监控每一个节点信息)</li>\n<li>每2秒，哨兵会向master库和slave的频道(<strong>sentinel</strong>:hello)发送自己的信息 （sentinel节点通过__sentinel__:hello频道进行信息交换，比如加入哨兵集群，分享自己节点数据）</li>\n<li>每1秒，哨兵会向master和slave以及其他哨兵节点发送PING命令（目的就是 redis节点的状态监控，还有领导选举，主备切换选择等）</li>\n</ol>\n<p>策略总结：</p>\n<p>​	1.尽量为 每一个节点部署一个哨兵</p>\n<p>​	2.哨兵也要搭建集群（防止哨兵单点故障）</p>\n<p>​	3.每一个节点都同时设置quorum的值超过半数（N/2）+1</p>\n<p>面试常问的问题：</p>\n<p>​	主从复制，以及哨兵 和集群之间区别。</p>\n<p>主从复制 是redis实现高可用的一个策略。将会有主节点 和从节点，从节点的数据完整的从主节点中复制一份。</p>\n<p>哨兵：当系统节点异常宕机的时候，开发者可以手动进行故障转移恢复，但是手动比较麻烦，所以通过哨兵机制自动进行监控和恢复。为了解决哨兵也会单点故障的问题，可以建立哨兵集群。</p>\n<p>集群：即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据，浪费内存且有木桶效应。为了最大化利用内存，可以采用集群，就是分布式存储。这个时候可以使用redis集群。将不同的数据分配到不同的节点中，这样就可以横向扩展，扩容。</p>\n', 1427644735320879106);
INSERT INTO `ms_article_body` VALUES (1427646424123830273, '## 什么是缓存击穿\n![1558597517593.png](http://qxx33orzv.hb-bkt.clouddn.com/01595931-0bd1-4b4c-a6c5-69c4fc4f847b.png)\n如图：\n\n 	1. 当用户根据key 查询数据时，先查询缓存，如果缓存有命中，返回，\n 	2. 但是如果缓存没有命中直接穿过缓存层，访问数据层 如果有，则存储指缓存，\n 	3. 但是同样如果没有命中，（也就是数据库中也没有数据）直接返回用户，但是不缓存\n\n这就是缓存的穿透。如果某一个key 请求量很大，但是存储层也没有数据，大量的请求都会达到存储层就会造成数据库压力巨大，有可能宕机的情况。\n## 缓存击穿的解决方案\n\n1.当缓存中没有命中的时候，从数据库中获取\n\n2.当数据库中也没有数据的时候，我们直接将null 作为值设置redis中的key上边。\n\n3.此时如果没有数据，一般情况下都需要设置一个过期时间，例如：5分钟失效。（为了避免过多的KEY 存储在redis中）\n\n4.返回给用户，\n\n5.用户再次访问时，已经有KEY了。此时KEY的值是null而已，这样就可以在缓存中命中，解决了缓存穿透的问题。\n\n#### 注意：缓存空对象会有两个问题：\n\n第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。\n\n 第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。\n\n##  什么是缓存雪崩\n如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。\n\n##### 如何解决\n\n这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。\n\n+ 限流 加锁排队\n\n在缓存失效后，通过对某一个key加锁或者是队列 来控制key的线程访问的数量。例如：某一个key 只允许一个线程进行 操作。\n\n+ 限流\n\n在缓存失效后，某一个key 做count统计限流，达到一定的阈值，直接丢弃，不再查询数据库。例如：令牌桶算法。等等。\n\n+ 数据预热\n\n在缓存失效应当尽量避免某一段时间，可以先进行数据预热，比如某些热门的商品。提前在上线之前，或者开放给用户使用之前，先进行loading 缓存中，这样用户使用的时候，直接从缓存中获取。要注意的是，要更加业务来进行过期时间的设置 ，尽量均匀。\n\n+ 做缓存降级（二级缓存策略）\n\n当分布式缓存失效的时候，可以采用本地缓存，本地缓存没有再查询数据库。这种方式，可以避免很多数据分布式缓存没有，就直接打到数据库的情况。\n\n\n\n\n', '<h2><a id=\"_0\"></a>什么是缓存击穿</h2>\n<p><img src=\"http://qxx33orzv.hb-bkt.clouddn.com/01595931-0bd1-4b4c-a6c5-69c4fc4f847b.png\" alt=\"1558597517593.png\" /><br />\n如图：</p>\n<pre><code>1. 当用户根据key 查询数据时，先查询缓存，如果缓存有命中，返回，\n2. 但是如果缓存没有命中直接穿过缓存层，访问数据层 如果有，则存储指缓存，\n3. 但是同样如果没有命中，（也就是数据库中也没有数据）直接返回用户，但是不缓存\n</code></pre>\n<p>这就是缓存的穿透。如果某一个key 请求量很大，但是存储层也没有数据，大量的请求都会达到存储层就会造成数据库压力巨大，有可能宕机的情况。</p>\n<h2><a id=\"_9\"></a>缓存击穿的解决方案</h2>\n<p>1.当缓存中没有命中的时候，从数据库中获取</p>\n<p>2.当数据库中也没有数据的时候，我们直接将null 作为值设置redis中的key上边。</p>\n<p>3.此时如果没有数据，一般情况下都需要设置一个过期时间，例如：5分钟失效。（为了避免过多的KEY 存储在redis中）</p>\n<p>4.返回给用户，</p>\n<p>5.用户再次访问时，已经有KEY了。此时KEY的值是null而已，这样就可以在缓存中命中，解决了缓存穿透的问题。</p>\n<h4><a id=\"_21\"></a>注意：缓存空对象会有两个问题：</h4>\n<p>第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</p>\n<p>第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</p>\n<h2><a id=\"_27\"></a>什么是缓存雪崩</h2>\n<p>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。</p>\n<h5><a id=\"_30\"></a>如何解决</h5>\n<p>这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。</p>\n<ul>\n<li>限流 加锁排队</li>\n</ul>\n<p>在缓存失效后，通过对某一个key加锁或者是队列 来控制key的线程访问的数量。例如：某一个key 只允许一个线程进行 操作。</p>\n<ul>\n<li>限流</li>\n</ul>\n<p>在缓存失效后，某一个key 做count统计限流，达到一定的阈值，直接丢弃，不再查询数据库。例如：令牌桶算法。等等。</p>\n<ul>\n<li>数据预热</li>\n</ul>\n<p>在缓存失效应当尽量避免某一段时间，可以先进行数据预热，比如某些热门的商品。提前在上线之前，或者开放给用户使用之前，先进行loading 缓存中，这样用户使用的时候，直接从缓存中获取。要注意的是，要更加业务来进行过期时间的设置 ，尽量均匀。</p>\n<ul>\n<li>做缓存降级（二级缓存策略）</li>\n</ul>\n<p>当分布式缓存失效的时候，可以采用本地缓存，本地缓存没有再查询数据库。这种方式，可以避免很多数据分布式缓存没有，就直接打到数据库的情况。</p>\n', 1427646422928453634);
INSERT INTO `ms_article_body` VALUES (1434503971032035329, 'gitee地址：https://gitee.com/tiangeng_lyp/boke_project\n\n', '<p>gitee地址：https://gitee.com/tiangeng_lyp/boke_project</p>\n', 1434503969752772610);

-- ----------------------------
-- Table structure for ms_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `ms_article_tag`;
CREATE TABLE `ms_article_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE,
  INDEX `tag_id`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1434503970503553026 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_article_tag
-- ----------------------------
INSERT INTO `ms_article_tag` VALUES (1, 1, 7);
INSERT INTO `ms_article_tag` VALUES (2, 1, 5);
INSERT INTO `ms_article_tag` VALUES (3, 1, 8);
INSERT INTO `ms_article_tag` VALUES (4, 9, 7);
INSERT INTO `ms_article_tag` VALUES (5, 10, 7);
INSERT INTO `ms_article_tag` VALUES (6, 10, 8);
INSERT INTO `ms_article_tag` VALUES (7, 10, 5);
INSERT INTO `ms_article_tag` VALUES (8, 10, 6);
INSERT INTO `ms_article_tag` VALUES (1405564731321802753, 1405916999732707300, 5);
INSERT INTO `ms_article_tag` VALUES (1427273234583134209, 1427273234172092417, 6);
INSERT INTO `ms_article_tag` VALUES (1427276446321115138, 1427276445754884097, 8);
INSERT INTO `ms_article_tag` VALUES (1427278900450328577, 1427278899737296897, 5);
INSERT INTO `ms_article_tag` VALUES (1427278901041725442, 1427278899737296897, 8);
INSERT INTO `ms_article_tag` VALUES (1427491230148751362, 1427491228018044929, 6);
INSERT INTO `ms_article_tag` VALUES (1427491230618513409, 1427491228018044929, 8);
INSERT INTO `ms_article_tag` VALUES (1427510753094561793, 1427510750640893954, 5);
INSERT INTO `ms_article_tag` VALUES (1427644735622868994, 1427644735320879106, 8);
INSERT INTO `ms_article_tag` VALUES (1427644735962607618, 1427644735320879106, 5);
INSERT INTO `ms_article_tag` VALUES (1427646423654068226, 1427646422928453634, 6);
INSERT INTO `ms_article_tag` VALUES (1434503970503553025, 1434503969752772610, 5);

-- ----------------------------
-- Table structure for ms_category
-- ----------------------------
DROP TABLE IF EXISTS `ms_category`;
CREATE TABLE `ms_category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_category
-- ----------------------------
INSERT INTO `ms_category` VALUES (1, '/static/category/front.png', '前端', '前端是什么，大前端');
INSERT INTO `ms_category` VALUES (2, '/static/category/back.png', '后端', '后端最牛叉');
INSERT INTO `ms_category` VALUES (3, '/static/category/lift.jpg', '生活', '生活趣事');
INSERT INTO `ms_category` VALUES (4, '/static/category/database.png', '数据库', '没数据库，啥也不管用');
INSERT INTO `ms_category` VALUES (5, '/static/category/language.png', '编程语言', '好多语言，该学哪个？');

-- ----------------------------
-- Table structure for ms_comment
-- ----------------------------
DROP TABLE IF EXISTS `ms_comment`;
CREATE TABLE `ms_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `create_date` bigint(20) NOT NULL,
  `article_id` bigint(11) NOT NULL,
  `author_id` bigint(20) NOT NULL,
  `parent_id` bigint(20) NOT NULL,
  `to_uid` bigint(20) NOT NULL,
  `level` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1427298507823263747 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_comment
-- ----------------------------
INSERT INTO `ms_comment` VALUES (1427286464042905602, '来了 老弟~', 1629126585383, 10, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1427286726941880322, '讲的真是全！', 1629126648080, 1427278899737296897, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1427287138025615362, 'Dubbo官网地址：http://dubbo.apache.org', 1629126746087, 1427276445754884097, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1427288743156396034, '讲的真实详细', 1629127128779, 1427273234172092417, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1427291719417737218, '图片没有显示出来~', 1629127838363, 1, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1427292535226642433, '怎末回事小老弟', 1629128032873, 1, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1427295038294994945, '图片路径不对吧', 1629128629657, 1, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1427295805835849730, '前端真难', 1629128812653, 9, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1427296959781154818, 'Dobbo也不过如此', 1629129087774, 1427276445754884097, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1427298085809172481, '入门案列', 1629129356243, 1, 1427297981920456706, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1427298507823263746, '我这边也没有显示图片', 1629129456858, 1, 1427297981920456706, 1427291719417737218, 1, '2');

-- ----------------------------
-- Table structure for ms_permission
-- ----------------------------
DROP TABLE IF EXISTS `ms_permission`;
CREATE TABLE `ms_permission`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_permission
-- ----------------------------
INSERT INTO `ms_permission` VALUES (1, '查询权限列表', '/admin/permission/permissionList', '查询权限列表');
INSERT INTO `ms_permission` VALUES (8, '删除权限', '/admin/permission/add', '删除权限');

-- ----------------------------
-- Table structure for ms_sys_log
-- ----------------------------
DROP TABLE IF EXISTS `ms_sys_log`;
CREATE TABLE `ms_sys_log`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_date` bigint(20) NULL DEFAULT NULL,
  `ip` varchar(15) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `method` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `module` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `nickname` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `operation` varchar(25) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `params` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `time` bigint(20) NULL DEFAULT NULL,
  `userid` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for ms_sys_user
-- ----------------------------
DROP TABLE IF EXISTS `ms_sys_user`;
CREATE TABLE `ms_sys_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `account` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '账号',
  `admin` bit(1) NULL DEFAULT NULL COMMENT '是否管理员',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `create_date` bigint(20) NULL DEFAULT NULL COMMENT '注册时间',
  `deleted` bit(1) NULL DEFAULT NULL COMMENT '是否删除',
  `email` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `last_login` bigint(20) NULL DEFAULT NULL COMMENT '最后登录时间',
  `mobile_phone_number` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码',
  `salt` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '加密盐',
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1427297981920456707 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_sys_user
-- ----------------------------
INSERT INTO `ms_sys_user` VALUES (1, 'piaopiao', b'1', '/static/img/logo.b3a48c0.png', 1629121375402, b'0', '1090404459@qq.com', 20210630223130, '1008611', '田埂、', '64c9ce4df8c4d838960d74bebfb0aa03', '12', '1');
INSERT INTO `ms_sys_user` VALUES (1427297981920456706, 'admin', b'1', '/static/img/logo.b3a48c0.png', 1629129331467, b'0', '', 1629129331467, NULL, 'admin', '64c9ce4df8c4d838960d74bebfb0aa03', '', '');

-- ----------------------------
-- Table structure for ms_tag
-- ----------------------------
DROP TABLE IF EXISTS `ms_tag`;
CREATE TABLE `ms_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_tag
-- ----------------------------
INSERT INTO `ms_tag` VALUES (5, '/static/tag/java.png', 'springboot');
INSERT INTO `ms_tag` VALUES (6, '/static/tag/java.png', 'spring');
INSERT INTO `ms_tag` VALUES (7, '/static/tag/java.png', 'springmvc');
INSERT INTO `ms_tag` VALUES (8, '/static/tag/css.png', 'springcloud');

SET FOREIGN_KEY_CHECKS = 1;
